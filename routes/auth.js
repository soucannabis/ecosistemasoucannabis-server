const express = require('express');
const crypto = require('crypto');
const CryptoJS = require('crypto-js');
const router = express.Router();

// ‚úÖ Fun√ß√£o para validar credenciais
async function validateUserCredentials(email, password) {
  try {
    console.log(`üîç [AUTH] Iniciando valida√ß√£o de credenciais para: ${email}`);
    
    // Buscar usu√°rio usando credenciais do servidor
    const userResponse = await fetch(`${process.env.DIRECTUS_API_URL}/items/Users?filter[email_account][_eq]=${email}`, {
      headers: {
        'Authorization': `Bearer ${process.env.DIRECTUS_API_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });
    
    console.log(`üîç [AUTH] Status da resposta da API: ${userResponse.status}`);
    
    const users = await userResponse.json();
    console.log(`üîç [AUTH] Dados retornados da API:`, JSON.stringify(users, null, 2));
    
    if (users.data && users.data.length > 0) {
      const user = users.data[0];
      console.log(`üîç [AUTH] Usu√°rio encontrado:`, {
        id: user.id,
        user_code: user.user_code,
        name: user.name,
        email: user.email_account,
        hasPassword: !!user.pass_account
      });
      
      // Se o usu√°rio n√£o tem senha definida (cadastro recente), permitir login
      if (!user.pass_account || user.pass_account === null) {
        console.log(`‚úÖ [AUTH] Login de usu√°rio rec√©m-cadastrado: ${email}`);
        return {
          id: user.id,
          user_code: user.user_code,
          name: user.name,
          email: user.email_account
        };
      }
      
      // Se o usu√°rio tem senha definida, validar credenciais
      console.log(`üîç [AUTH] Validando senha para usu√°rio: ${email}`);
      const decryptedPassword = decryptPassword(user.pass_account, process.env.PASS_ENCRYPT);
      
      // Verificar se a descriptografia foi bem-sucedida
      if (!decryptedPassword) {
        console.log(`‚ùå [AUTH] Erro ao descriptografar senha do usu√°rio ${email}`);
        return null;
      }
      
      console.log(`üîç [AUTH] Senha descriptografada com sucesso para: ${email}`);
      
      // Comparar senhas no servidor
      const passwordMatch = decryptedPassword === password;
      console.log(`üîç [AUTH] Compara√ß√£o de senhas para ${email}: ${passwordMatch ? 'MATCH' : 'NO MATCH'}`);
      
      if (passwordMatch) {
        console.log(`‚úÖ [AUTH] Credenciais v√°lidas para: ${email}`);
        return {
          id: user.id,
          user_code: user.user_code,
          name: user.name,
          email: user.email_account
        };
      } else {
        console.log(`‚ùå [AUTH] Senha incorreta para: ${email}`);
      }
    } else {
      console.log(`‚ùå [AUTH] Usu√°rio n√£o encontrado: ${email}`);
    }
    
    return null;
  } catch (error) {
    console.error('‚ùå [AUTH] Erro na valida√ß√£o:', error);
    return null;
  }
}

// ‚úÖ Fun√ß√£o para descriptografar senha (usando CryptoJS para compatibilidade)
function decryptPassword(encryptedPassword, key) {
  try {
    console.log(`üîç [DECRYPT] Iniciando descriptografia de senha`);
    console.log(`üîç [DECRYPT] Senha criptografada (primeiros 20 chars): ${encryptedPassword.substring(0, 20)}...`);
    console.log(`üîç [DECRYPT] Chave de criptografia dispon√≠vel: ${!!key}`);
    
    if (!encryptedPassword || !key) {
      console.log(`‚ùå [DECRYPT] Par√¢metros inv√°lidos`);
      return null;
    }
    
    // Usar CryptoJS para compatibilidade com o sistema existente
    const bytes = CryptoJS.AES.decrypt(encryptedPassword, key);
    const decrypted = bytes.toString(CryptoJS.enc.Utf8);
    
    if (!decrypted) {
      console.log(`‚ùå [DECRYPT] Falha na descriptografia - resultado vazio`);
      return null;
    }
    
    console.log(`‚úÖ [DECRYPT] Senha descriptografada com sucesso`);
    return decrypted;
  } catch (error) {
    console.error('‚ùå [DECRYPT] Erro na descriptografia:', error);
    return null;
  }
}

// ‚úÖ Fun√ß√£o para gerar token seguro
function generateSecureToken() {
  const token = crypto.randomBytes(32).toString('hex');
  console.log(`üîç [TOKEN] Token de sess√£o gerado: ${token.substring(0, 20)}...`);
  console.log(`üîç [TOKEN] Tamanho do token: ${token.length} caracteres`);
  return token;
}

// ‚úÖ Fun√ß√£o para salvar sess√£o
async function saveUserSession(userId, sessionToken) {
  try {
    console.log(`üîç [SESSION] Salvando sess√£o para usu√°rio ID: ${userId}`);
    console.log(`üîç [SESSION] Token da sess√£o: ${sessionToken.substring(0, 20)}...`);
    
    const expiresAt = new Date(Date.now() + 3600000); // 1 hora
    console.log(`üîç [SESSION] Sess√£o expira em: ${expiresAt.toISOString()}`);
    
    const sessionData = {
      session_token: sessionToken,
      session_expires: expiresAt.toISOString(),
      last_activity: new Date().toISOString(),
      is_session_active: true
    };
    
    console.log(`üîç [SESSION] Dados da sess√£o:`, JSON.stringify(sessionData, null, 2));
    
    const response = await fetch(`${process.env.DIRECTUS_API_URL}/items/Users/${userId}`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${process.env.DIRECTUS_API_TOKEN}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(sessionData)
    });
    
    console.log(`üîç [SESSION] Status da resposta da API: ${response.status}`);
    
    if (response.ok) {
      console.log(`‚úÖ [SESSION] Sess√£o salva com sucesso para usu√°rio: ${userId}`);
    } else {
      const errorText = await response.text();
      console.log(`‚ùå [SESSION] Erro ao salvar sess√£o: ${errorText}`);
    }
    
    return response.ok;
  } catch (error) {
    console.error('‚ùå [SESSION] Erro ao salvar sess√£o:', error);
    return false;
  }
}

// ‚úÖ Fun√ß√£o para invalidar sess√£o
async function invalidateUserSession(sessionToken) {
  try {
    // Buscar usu√°rio pelo session_token
    const userResponse = await fetch(`${process.env.DIRECTUS_API_URL}/items/Users?filter[session_token][_eq]=${sessionToken}`, {
      headers: {
        'Authorization': `Bearer ${process.env.DIRECTUS_API_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });
    
    const users = await userResponse.json();
    
    if (users.data && users.data.length > 0) {
      const user = users.data[0];
      
      // Invalidar sess√£o do usu√°rio
      const response = await fetch(`${process.env.DIRECTUS_API_URL}/items/Users/${user.id}`, {
        method: 'PATCH',
        headers: {
          'Authorization': `Bearer ${process.env.DIRECTUS_API_TOKEN}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          is_session_active: false,
          session_token: null,
          session_expires: null
        })
      });
      
      return response.ok;
    }
    
    return true; // Se n√£o encontrou usu√°rio, considera como sucesso
  } catch (error) {
    console.error('Erro ao invalidar sess√£o:', error);
    return false;
  }
}

// ‚úÖ Middleware de autentica√ß√£o
async function authMiddleware(req, res, next) {
  try {
    console.log(`üîç [MIDDLEWARE] Iniciando verifica√ß√£o de autentica√ß√£o`);
    console.log(`üîç [MIDDLEWARE] URL da requisi√ß√£o: ${req.originalUrl}`);
    console.log(`üîç [MIDDLEWARE] M√©todo: ${req.method}`);
    console.log(`üîç [MIDDLEWARE] Headers:`, JSON.stringify(req.headers, null, 2));
    console.log(`üîç [MIDDLEWARE] Cookies recebidos:`, JSON.stringify(req.cookies, null, 2));
    
    const sessionToken = req.cookies.session_token;
    
    if (!sessionToken) {
      console.log(`‚ùå [MIDDLEWARE] Token de sess√£o n√£o encontrado nos cookies`);
      return res.status(401).json({ success: false, message: 'N√£o autenticado' });
    }
    
    console.log(`üîç [MIDDLEWARE] Token de sess√£o encontrado: ${sessionToken.substring(0, 20)}...`);
    
    // Verificar sess√£o no banco (buscar usu√°rio pelo session_token)
    console.log(`üîç [MIDDLEWARE] Verificando sess√£o no banco de dados`);
    const userResponse = await fetch(`${process.env.DIRECTUS_API_URL}/items/Users?filter[session_token][_eq]=${sessionToken}&filter[is_session_active][_eq]=true`, {
      headers: {
        'Authorization': `Bearer ${process.env.DIRECTUS_API_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });
    
    console.log(`üîç [MIDDLEWARE] Status da resposta da API: ${userResponse.status}`);
    const users = await userResponse.json();
    console.log(`üîç [MIDDLEWARE] Dados retornados da API:`, JSON.stringify(users, null, 2));
    
    if (!users.data || users.data.length === 0) {
      console.log(`‚ùå [MIDDLEWARE] Sess√£o n√£o encontrada ou inativa no banco`);
      return res.status(401).json({ success: false, message: 'Sess√£o inv√°lida' });
    }
    
    const user = users.data[0];
    console.log(`üîç [MIDDLEWARE] Usu√°rio encontrado:`, {
      id: user.id,
      user_code: user.user_code,
      name: user.name,
      email: user.email_account,
      session_expires: user.session_expires,
      is_session_active: user.is_session_active
    });
    
    // Verificar se n√£o expirou
    const now = new Date();
    const expiresAt = new Date(user.session_expires);
    console.log(`üîç [MIDDLEWARE] Verificando expira√ß√£o - Agora: ${now.toISOString()}, Expira: ${expiresAt.toISOString()}`);
    
    if (now > expiresAt) {
      console.log(`‚ùå [MIDDLEWARE] Sess√£o expirada - invalidando`);
      // Marcar como inativa
      await invalidateUserSession(sessionToken);
      return res.status(401).json({ success: false, message: 'Sess√£o expirada' });
    }
    
    console.log(`‚úÖ [MIDDLEWARE] Sess√£o v√°lida - adicionando usu√°rio √† requisi√ß√£o`);
    
    // Adicionar dados do usu√°rio √† requisi√ß√£o
    req.user = {
      id: user.id,
      user_code: user.user_code,
      name: user.name,
      email: user.email_account
    };
    
    console.log(`üîç [MIDDLEWARE] Atualizando √∫ltima atividade do usu√°rio`);
    
    // Atualizar √∫ltima atividade
    await fetch(`${process.env.DIRECTUS_API_URL}/items/Users/${user.id}`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${process.env.DIRECTUS_API_TOKEN}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        last_activity: new Date().toISOString()
      })
    });
    
    console.log(`‚úÖ [MIDDLEWARE] Autentica√ß√£o bem-sucedida - prosseguindo`);
    next();
  } catch (error) {
    console.error('‚ùå [MIDDLEWARE] Erro no middleware de auth:', error);
    res.status(500).json({ success: false, message: 'Erro interno' });
  }
}

// ‚úÖ ROTA: POST /api/auth/login
router.post('/login', async (req, res) => {
  try {
    console.log(`üîç [LOGIN] Iniciando processo de login`);
    console.log(`üîç [LOGIN] Headers da requisi√ß√£o:`, JSON.stringify(req.headers, null, 2));
    console.log(`üîç [LOGIN] Body da requisi√ß√£o:`, JSON.stringify(req.body, null, 2));
    console.log(`üîç [LOGIN] URL completa: ${req.originalUrl}`);
    console.log(`üîç [LOGIN] M√©todo: ${req.method}`);
    
    const { email, password } = req.body;
    
    // Validar entrada
    if (!email || !password) {
      console.log(`‚ùå [LOGIN] Dados obrigat√≥rios n√£o fornecidos - Email: ${!!email}, Senha: ${!!password}`);
      return res.status(400).json({ 
        success: false, 
        message: 'Email e senha s√£o obrigat√≥rios' 
      });
    }
    
    console.log(`üîç [LOGIN] Dados de entrada v√°lidos - Email: ${email}`);
    
    // Validar credenciais
    const user = await validateUserCredentials(email, password);
    
    if (user) {
      console.log(`‚úÖ [LOGIN] Usu√°rio autenticado com sucesso:`, {
        id: user.id,
        user_code: user.user_code,
        name: user.name,
        email: user.email
      });
      
      // Gerar token √∫nico
      const sessionToken = generateSecureToken();
      
      // Salvar sess√£o
      const sessionSaved = await saveUserSession(user.id, sessionToken);
      
      if (sessionSaved) {
        console.log(`üîç [COOKIE] Configurando cookie de sess√£o`);
        console.log(`üîç [COOKIE] Nome: session_token`);
        console.log(`üîç [COOKIE] Valor: ${sessionToken.substring(0, 20)}...`);
        console.log(`üîç [COOKIE] HttpOnly: true`);
        console.log(`üîç [COOKIE] Secure: ${process.env.NODE_ENV === 'production'}`);
        console.log(`üîç [COOKIE] Origem: ${req.headers.origin || 'sem origem'}`);
        console.log(`üîç [COOKIE] Host: ${req.headers.host}`);
        console.log(`üîç [COOKIE] SameSite: strict (funciona para cross-origin)`);
        console.log(`üîç [COOKIE] MaxAge: 24 horas`);
        
        // Definir cookie HttpOnly com configura√ß√£o que funciona para cross-origin
        res.cookie('session_token', sessionToken, {
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'strict',
          path: '/',
          maxAge: 24 * 60 * 60 * 1000 // 24 horas
        });
        
        console.log(`‚úÖ [COOKIE] Cookie configurado com sucesso`);
        
        // Log de auditoria
        console.log(`‚úÖ [LOGIN] Login realizado: ${user.email} - ${new Date().toISOString()}`);
        
        res.json({
          success: true,
          user: {
            user_code: user.user_code,
            name: user.name,
            email: user.email
          }
        });
      } else {
        console.log(`‚ùå [LOGIN] Falha ao salvar sess√£o para usu√°rio: ${user.email}`);
        res.status(500).json({ 
          success: false, 
          message: 'Erro ao criar sess√£o' 
        });
      }
    } else {
      // Log de tentativa de login inv√°lida
      console.log(`‚ùå [LOGIN] Tentativa de login inv√°lida: ${email} - ${new Date().toISOString()}`);
      
      res.status(401).json({ 
        success: false, 
        message: 'Credenciais inv√°lidas' 
      });
    }
  } catch (error) {
    console.error('‚ùå [LOGIN] Erro no login:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Erro interno do servidor' 
    });
  }
});

// ‚úÖ ROTA: GET /api/auth/me
router.get('/me', authMiddleware, async (req, res) => {
  try {
    res.json({
      success: true,
      user: {
        user_code: req.user.user_code,
        name: req.user.name,
        email: req.user.email
      }
    });
  } catch (error) {
    console.error('Erro ao obter usu√°rio:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Erro interno do servidor' 
    });
  }
});

// ‚úÖ ROTA: POST /api/auth/logout
router.post('/logout', authMiddleware, async (req, res) => {
  try {
    const sessionToken = req.cookies.session_token;
    
    // Invalidar sess√£o no banco
    await invalidateUserSession(sessionToken);
    
    // Limpar cookie
    res.clearCookie('session_token');
    
    // Log de auditoria
    console.log(`‚úÖ Logout realizado: ${req.user.email} - ${new Date().toISOString()}`);
    
    res.json({ success: true });
  } catch (error) {
    console.error('Erro no logout:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Erro interno do servidor' 
    });
  }
});

module.exports = { router, authMiddleware };
