# üîê Manual de Implementa√ß√£o - Backend Seguro

## üìã Vis√£o Geral

Este manual fornece instru√ß√µes detalhadas para implementar o sistema de autentica√ß√£o seguro no backend, substituindo a vulnerabilidade cr√≠tica da chave API compartilhada por um sistema robusto baseado em cookies HttpOnly e gerenciamento de sess√µes individuais.

---

## üóÑÔ∏è ESTRUTURA DO BANCO DE DADOS

### **1. Campos na Tabela `Users` (Adicionar Apenas 4 Campos de Sess√£o)**

Adicione apenas os seguintes 4 campos necess√°rios para o gerenciamento de sess√µes:

```sql
-- ‚úÖ CAMPOS DE SESS√ÉO (adicionar para gerenciamento de sess√µes)
ALTER TABLE Users ADD COLUMN IF NOT EXISTS session_token VARCHAR(255) UNIQUE;
ALTER TABLE Users ADD COLUMN IF NOT EXISTS session_expires TIMESTAMP;
ALTER TABLE Users ADD COLUMN IF NOT EXISTS last_activity TIMESTAMP;
ALTER TABLE Users ADD COLUMN IF NOT EXISTS is_session_active BOOLEAN DEFAULT FALSE;

```
OS CAMPOS JA FORAM CRIADOS MANUALMENTE DO DATABASE.
---

## üõ†Ô∏è IMPLEMENTA√á√ÉO DAS ROTAS DA API

### **1. Configura√ß√£o Inicial do Servidor**

#### **1.1 Instalar Depend√™ncias Necess√°rias**
```bash
npm install cookie-parser cors express
npm install --save-dev nodemon
```

#### **1.2 Configura√ß√£o Base do Servidor (`server.js`)**
```javascript
const express = require('express');
const cookieParser = require('cookie-parser');
const cors = require('cors');
const crypto = require('crypto');

const app = express();
const PORT = process.env.PORT || 3000;

// ‚úÖ Configurar CORS para cookies
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:5173',
  credentials: true // Permite cookies
}));

// ‚úÖ Middlewares essenciais
app.use(express.json());
app.use(cookieParser());

// ‚úÖ Vari√°veis de ambiente seguras (apenas no servidor)
const DIRECTUS_API_TOKEN = process.env.DIRECTUS_API_TOKEN;
const DIRECTUS_API_URL = process.env.DIRECTUS_API_URL;
const PASS_ENCRYPT_KEY = process.env.PASS_ENCRYPT_KEY;
const JWT_SECRET = process.env.JWT_SECRET;

// ‚úÖ Configura√ß√£o de cookies seguros
app.use((req, res, next) => {
  res.cookie = (name, value, options = {}) => {
    const defaultOptions = {
      httpOnly: true,        // N√£o acess√≠vel via JavaScript
      secure: process.env.NODE_ENV === 'production', // HTTPS em produ√ß√£o
      sameSite: 'strict',    // Prote√ß√£o contra CSRF
      path: '/'              // Dispon√≠vel em todo o site
    };
    
    const cookieString = `${name}=${value}; ${Object.entries({...defaultOptions, ...options})
      .map(([key, val]) => `${key}=${val}`)
      .join('; ')}`;
    
    res.setHeader('Set-Cookie', cookieString);
  };
  next();
});

// ‚úÖ Importar e aplicar middleware de filtro de dados
const dataFilterMiddleware = require('./middleware/dataFilterMiddleware');
app.use('/api', dataFilterMiddleware);

// ‚úÖ Importar rotas de autentica√ß√£o
const authRoutes = require('./routes/auth');
app.use('/api/auth', authRoutes);

// ‚úÖ Importar rotas protegidas
const protectedRoutes = require('./routes/protected');
app.use('/api/directus', protectedRoutes);

// ‚úÖ Iniciar servidor
app.listen(PORT, () => {
  console.log(`üöÄ Servidor rodando na porta ${PORT}`);
  console.log(`üîí Sistema de autentica√ß√£o seguro ativo`);
});
```

### **2. Rotas de Autentica√ß√£o (`routes/auth.js`)**

#### **2.1 POST `/api/auth/login`**
```javascript
const express = require('express');
const crypto = require('crypto');
const router = express.Router();

// ‚úÖ Fun√ß√£o para validar credenciais
async function validateUserCredentials(email, password) {
  try {
    // Buscar usu√°rio usando credenciais do servidor
    const userResponse = await fetch(`${process.env.DIRECTUS_API_URL}/items/Users?filter[email_account][_eq]=${email}`, {
      headers: {
        'Authorization': `Bearer ${process.env.DIRECTUS_API_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });
    
    const users = await userResponse.json();
    
    if (users.data && users.data.length > 0) {
      const user = users.data[0];
      
      // Descriptografar senha no servidor usando chave segura
      const decryptedPassword = decryptPassword(user.pass_account, process.env.PASS_ENCRYPT_KEY);
      
      // Comparar senhas no servidor
      if (decryptedPassword === password) {
        return {
          id: user.id,
          user_code: user.user_code,
          name: user.name,
          email: user.email_account
        };
      }
    }
    
    return null;
  } catch (error) {
    console.error('Erro na valida√ß√£o:', error);
    return null;
  }
}

// ‚úÖ Fun√ß√£o para descriptografar senha
function decryptPassword(encryptedPassword, key) {
  try {
    const decipher = crypto.createDecipher('aes-256-cbc', key);
    let decrypted = decipher.update(encryptedPassword, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
  } catch (error) {
    console.error('Erro na descriptografia:', error);
    return null;
  }
}

// ‚úÖ Fun√ß√£o para gerar token seguro
function generateSecureToken() {
  return crypto.randomBytes(32).toString('hex');
}

// ‚úÖ Fun√ß√£o para salvar sess√£o
async function saveUserSession(userId, sessionToken) {
  try {
    const expiresAt = new Date(Date.now() + 3600000); // 1 hora
    
    const sessionData = {
      session_token: sessionToken,
      session_expires: expiresAt.toISOString(),
      last_activity: new Date().toISOString(),
      is_session_active: true
    };
    
    const response = await fetch(`${process.env.DIRECTUS_API_URL}/items/Users/${userId}`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${process.env.DIRECTUS_API_TOKEN}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(sessionData)
    });
    
    return response.ok;
  } catch (error) {
    console.error('Erro ao salvar sess√£o:', error);
    return false;
  }
}

// ‚úÖ ROTA: POST /api/auth/login
router.post('/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // Validar entrada
    if (!email || !password) {
      return res.status(400).json({ 
        success: false, 
        message: 'Email e senha s√£o obrigat√≥rios' 
      });
    }
    
    // Validar credenciais
    const user = await validateUserCredentials(email, password);
    
    if (user) {
      // Gerar token √∫nico
      const sessionToken = generateSecureToken();
      
      // Salvar sess√£o
      const sessionSaved = await saveUserSession(user.id, sessionToken);
      
      if (sessionSaved) {
        // Definir cookie HttpOnly
        res.cookie('session_token', sessionToken, {
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'strict',
          maxAge: 3600000 // 1 hora
        });
        
        // Log de auditoria
        console.log(`‚úÖ Login realizado: ${user.email} - ${new Date().toISOString()}`);
        
        res.json({
          success: true,
          user: {
            user_code: user.user_code,
            name: user.name,
            email: user.email
          }
        });
      } else {
        res.status(500).json({ 
          success: false, 
          message: 'Erro ao criar sess√£o' 
        });
      }
    } else {
      // Log de tentativa de login inv√°lida
      console.log(`‚ùå Tentativa de login inv√°lida: ${email} - ${new Date().toISOString()}`);
      
      res.status(401).json({ 
        success: false, 
        message: 'Credenciais inv√°lidas' 
      });
    }
  } catch (error) {
    console.error('Erro no login:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Erro interno do servidor' 
    });
  }
});

module.exports = router;
```

#### **2.2 GET `/api/auth/me`**
```javascript
// ‚úÖ Middleware de autentica√ß√£o
async function authMiddleware(req, res, next) {
  try {
    const sessionToken = req.cookies.session_token;
    
    if (!sessionToken) {
      return res.status(401).json({ success: false, message: 'N√£o autenticado' });
    }
    
    // Verificar sess√£o no banco (buscar usu√°rio pelo session_token)
    const userResponse = await fetch(`${process.env.DIRECTUS_API_URL}/items/Users?filter[session_token][_eq]=${sessionToken}&filter[is_session_active][_eq]=true`, {
      headers: {
        'Authorization': `Bearer ${process.env.DIRECTUS_API_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });
    
    const users = await userResponse.json();
    
    if (!users.data || users.data.length === 0) {
      return res.status(401).json({ success: false, message: 'Sess√£o inv√°lida' });
    }
    
    const user = users.data[0];
    
    // Verificar se n√£o expirou
    if (new Date() > new Date(user.session_expires)) {
      // Marcar como inativa
      await invalidateUserSession(sessionToken);
      return res.status(401).json({ success: false, message: 'Sess√£o expirada' });
    }
    
    // Adicionar dados do usu√°rio √† requisi√ß√£o
    req.user = {
      id: user.id,
      user_code: user.user_code,
      name: user.name,
      email: user.email_account
    };
    
    // Atualizar √∫ltima atividade
    await fetch(`${process.env.DIRECTUS_API_URL}/items/Users/${user.id}`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${process.env.DIRECTUS_API_TOKEN}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        last_activity: new Date().toISOString()
      })
    });
    
    next();
  } catch (error) {
    console.error('Erro no middleware de auth:', error);
    res.status(500).json({ success: false, message: 'Erro interno' });
  }
}

// ‚úÖ ROTA: GET /api/auth/me
router.get('/me', authMiddleware, async (req, res) => {
  try {
    res.json({
      success: true,
      user: {
        user_code: req.user.user_code,
        name: req.user.name,
        email: req.user.email
      }
    });
  } catch (error) {
    console.error('Erro ao obter usu√°rio:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Erro interno do servidor' 
    });
  }
});

module.exports = { router, authMiddleware };
```

#### **2.3 POST `/api/auth/logout`**
```javascript
// ‚úÖ Fun√ß√£o para invalidar sess√£o
async function invalidateUserSession(sessionToken) {
  try {
    // Buscar usu√°rio pelo session_token
    const userResponse = await fetch(`${process.env.DIRECTUS_API_URL}/items/Users?filter[session_token][_eq]=${sessionToken}`, {
      headers: {
        'Authorization': `Bearer ${process.env.DIRECTUS_API_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });
    
    const users = await userResponse.json();
    
    if (users.data && users.data.length > 0) {
      const user = users.data[0];
      
      // Invalidar sess√£o do usu√°rio
      const response = await fetch(`${process.env.DIRECTUS_API_URL}/items/Users/${user.id}`, {
        method: 'PATCH',
        headers: {
          'Authorization': `Bearer ${process.env.DIRECTUS_API_TOKEN}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          is_session_active: false,
          session_token: null,
          session_expires: null
        })
      });
      
      return response.ok;
    }
    
    return true; // Se n√£o encontrou usu√°rio, considera como sucesso
  } catch (error) {
    console.error('Erro ao invalidar sess√£o:', error);
    return false;
  }
}

// ‚úÖ ROTA: POST /api/auth/logout
router.post('/logout', authMiddleware, async (req, res) => {
  try {
    const sessionToken = req.cookies.session_token;
    
    // Invalidar sess√£o no banco
    await invalidateUserSession(sessionToken);
    
    // Limpar cookie
    res.clearCookie('session_token');
    
    // Log de auditoria
    console.log(`‚úÖ Logout realizado: ${req.user.email} - ${new Date().toISOString()}`);
    
    res.json({ success: true });
  } catch (error) {
    console.error('Erro no logout:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Erro interno do servidor' 
    });
  }
});

module.exports = router;
```

### **3. Rotas Protegidas (`routes/protected.js`)**

#### **3.1 POST `/api/directus/user` (Protegido)**
```javascript
const express = require('express');
const { authMiddleware } = require('./auth');
const router = express.Router();

// ‚úÖ ROTA: POST /api/directus/user
router.post('/user', authMiddleware, async (req, res) => {
  try {
    const { code_user } = req.body;
    
    // Verificar se o usu√°rio pode acessar esses dados
    if (req.user.user_code !== code_user) {
      console.log(`‚ùå Tentativa de acesso negado: ${req.user.email} tentou acessar dados de ${code_user}`);
      return res.status(403).json({ 
        success: false, 
        message: 'Acesso negado' 
      });
    }
    
    // Buscar dados completos do usu√°rio
    const userResponse = await fetch(`${process.env.DIRECTUS_API_URL}/items/Users?filter[user_code][_eq]=${code_user}`, {
      headers: {
        'Authorization': `Bearer ${process.env.DIRECTUS_API_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });
    
    const userData = await userResponse.json();
    
    if (userData.data && userData.data.length > 0) {
      // ‚úÖ Filtrar dados sens√≠veis - retornar apenas campos necess√°rios
      const safeUserData = {
        id: userData.data[0].id,
        user_code: userData.data[0].user_code,
        name: userData.data[0].name,
        email: userData.data[0].email_account,
        // Adicionar outros campos n√£o sens√≠veis conforme necess√°rio
      };
      
      res.json(safeUserData);
    } else {
      res.status(404).json({ 
        success: false, 
        message: 'Usu√°rio n√£o encontrado' 
      });
    }
  } catch (error) {
    console.error('Erro ao buscar usu√°rio:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Erro interno do servidor' 
    });
  }
});

module.exports = router;
```

---

## üîç MIDDLEWARE DE FILTRO DE DADOS

### **1. Implementa√ß√£o do `dataFilterMiddleware.js`**

Crie o arquivo `middleware/dataFilterMiddleware.js`:

```javascript
const dataFilterMiddleware = (req, res, next) => {
  // Intercepta res.json() para filtrar dados
  const originalJson = res.json;
  res.json = function(data) {
    const filteredData = filterDataByPath(data, req);
    return originalJson.call(this, filteredData);
  };
  next();
};

// ‚úÖ Fun√ß√£o principal de filtragem
function filterDataByPath(data, req) {
  const route = req.baseUrl + req.path;
  const method = req.method;
  const query = req.query;
  const page = query?.info?.split("->")[0]?.trim();

  // ‚úÖ Configura√ß√£o de filtros adaptada para o sistema atual
  const filters = {
    // Filtros para autentica√ß√£o
    '/api/auth/me': {
      'default': {
        'GET': {
          allowedFields: ['success', 'user']
        }
      }
    },

    // Filtros para dados de usu√°rio
    '/api/directus/user': {
      'default': {
        'POST': {
          blockedFields: ['pass_account', 'internal_notes', 'admin_notes']
        }
      }
    },

    // Filtros para recupera√ß√£o de senha
    '/api/directus/user/verify-email': {
      '/nova-senha': {
        'GET': {
          allowedFields: ['email', 'id', 'user_code']
        },
        'POST': {
          allowedFields: ['success', 'message']
        }
      }
    },

    // Filtros para cria√ß√£o de usu√°rio
    '/api/directus/create-user': {
      'default': {
        'POST': {
          allowedFields: ['success', 'user_code', 'message']
        }
      }
    },

    // Filtros para busca de usu√°rios
    '/api/directus/search': {
      'default': {
        'POST': {
          blockedFields: ['pass_account', 'internal_notes', 'admin_notes', 'personal_data']
        }
      }
    },

    // Filtros para upload de documentos
    '/api/directus/documents': {
      'default': {
        'POST': {
          allowedFields: ['success', 'message', 'file_id', 'file_url']
        },
        'GET': {
          blockedFields: ['internal_path', 'admin_notes']
        }
      }
    },

    // Filtros para agendamentos m√©dicos
    '/api/directus/medical-appointment': {
      'default': {
        'POST': {
          allowedFields: ['success', 'message', 'appointment_id']
        },
        'GET': {
          blockedFields: ['internal_notes', 'admin_notes']
        }
      }
    },

    // Filtros para dados de associados
    '/api/directus/associate-signup': {
      'default': {
        'POST': {
          allowedFields: ['success', 'message', 'user_code']
        }
      }
    },

    // Filtros para dados de pacientes
    '/api/directus/patient-signup': {
      'default': {
        'POST': {
          allowedFields: ['success', 'message', 'user_code']
        }
      }
    }
  };

  // ‚úÖ Buscar configura√ß√£o de filtro
  const filterConfig = findFilterConfig(filters, route, page, method);
  
  if (filterConfig) {
    // ‚úÖ Aplicar filtro
    return applyFilter(data, filterConfig);
  }
  
  // ‚úÖ Se n√£o h√° filtro configurado, retornar dados originais
  return data;
}

// ‚úÖ Fun√ß√£o para encontrar configura√ß√£o de filtro
function findFilterConfig(filters, route, page, method) {
  // Buscar configura√ß√£o espec√≠fica para a rota
  const routeConfig = filters[route];
  if (!routeConfig) return null;

  // Buscar configura√ß√£o para a p√°gina espec√≠fica
  const pageConfig = routeConfig[page] || routeConfig['default'];
  if (!pageConfig) return null;

  // Buscar configura√ß√£o para o m√©todo HTTP
  return pageConfig[method] || pageConfig['default'];
}

// ‚úÖ Fun√ß√£o para aplicar filtro aos dados
function applyFilter(data, config) {
  if (!data) return data;

  // ‚úÖ Tratar arrays
  if (Array.isArray(data)) {
    return data.map(item => filterObject(item, config));
  }

  // ‚úÖ Tratar objetos √∫nicos
  return filterObject(data, config);
}

// ‚úÖ Fun√ß√£o para filtrar objeto individual
function filterObject(obj, config) {
  if (!obj || typeof obj !== 'object') return obj;

  const result = {};

  // ‚úÖ Campos que sempre passam
  const specialFields = ['success', 'message', 'error', 'count', 'total', 'data'];

  Object.keys(obj).forEach(key => {
    // ‚úÖ Campos especiais sempre passam
    if (specialFields.includes(key)) {
      result[key] = obj[key];
      return;
    }

    // ‚úÖ Aplicar filtro de campos permitidos
    if (config.allowedFields) {
      if (config.allowedFields.includes(key)) {
        result[key] = obj[key];
      }
      return;
    }

    // ‚úÖ Aplicar filtro de campos bloqueados
    if (config.blockedFields) {
      if (!config.blockedFields.includes(key)) {
        result[key] = obj[key];
      }
      return;
    }

    // ‚úÖ Se n√£o h√° configura√ß√£o espec√≠fica, manter campo
    result[key] = obj[key];
  });

  return result;
}

module.exports = dataFilterMiddleware;
```

### **2. Aplica√ß√£o do Middleware**

O middleware deve ser aplicado no `server.js` antes das rotas:

```javascript
// ‚úÖ Importar middleware de filtro de dados
const dataFilterMiddleware = require('./middleware/dataFilterMiddleware');

// ‚úÖ Aplicar middleware a todas as rotas /api/*
app.use('/api', dataFilterMiddleware);

// ‚úÖ Importar rotas (ap√≥s o middleware)
const authRoutes = require('./routes/auth');
const protectedRoutes = require('./routes/protected');

app.use('/api/auth', authRoutes);
app.use('/api/directus', protectedRoutes);
```

---

## üßπ LIMPEZA AUTOM√ÅTICA DE SESS√ïES

### **1. Job de Limpeza (Adicionar ao `server.js`)**

```javascript
// ‚úÖ Limpeza autom√°tica de sess√µes (executar a cada hora)
setInterval(async () => {
  try {
    const now = new Date().toISOString();
    
    // Buscar usu√°rios com sess√µes expiradas
    const expiredUsersResponse = await fetch(`${process.env.DIRECTUS_API_URL}/items/Users?filter[session_expires][_lt]=${now}&filter[is_session_active][_eq]=true`, {
      headers: {
        'Authorization': `Bearer ${process.env.DIRECTUS_API_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });
    
    const expiredUsers = await expiredUsersResponse.json();
    
    if (expiredUsers.data && expiredUsers.data.length > 0) {
      // Invalidar sess√µes expiradas
      for (const user of expiredUsers.data) {
        await fetch(`${process.env.DIRECTUS_API_URL}/items/Users/${user.id}`, {
          method: 'PATCH',
          headers: {
            'Authorization': `Bearer ${process.env.DIRECTUS_API_TOKEN}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            is_session_active: false,
            session_token: null,
            session_expires: null
          })
        });
      }
      
      console.log(`üßπ ${expiredUsers.data.length} sess√µes expiradas limpas: ${new Date().toISOString()}`);
    }
  } catch (error) {
    console.error('‚ùå Erro ao limpar sess√µes:', error);
  }
}, 3600000); // 1 hora
```

---

## üîß VARI√ÅVEIS DE AMBIENTE

### **1. Arquivo `.env` (Criar no servidor)**

```bash
# ‚úÖ Configura√ß√µes do servidor
PORT=3000
NODE_ENV=production

# ‚úÖ Configura√ß√µes do frontend
FRONTEND_URL=https://seudominio.com

# ‚úÖ Credenciais do Directus (APENAS NO SERVIDOR)
DIRECTUS_API_TOKEN=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
DIRECTUS_API_URL=https://directus-production-3403.up.railway.app
PASS_ENCRYPT_KEY=sua_chave_de_criptografia_super_secreta
JWT_SECRET=sua_chave_jwt_super_secreta

# ‚úÖ Configura√ß√µes de seguran√ßa
SESSION_TIMEOUT=3600000
MAX_LOGIN_ATTEMPTS=5
```

### **2. Verifica√ß√£o de Vari√°veis**

Adicione ao in√≠cio do `server.js`:

```javascript
// ‚úÖ Verificar vari√°veis de ambiente obrigat√≥rias
const requiredEnvVars = [
  'DIRECTUS_API_TOKEN',
  'DIRECTUS_API_URL',
  'PASS_ENCRYPT_KEY',
  'JWT_SECRET'
];

const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);

if (missingVars.length > 0) {
  console.error('‚ùå Vari√°veis de ambiente obrigat√≥rias n√£o encontradas:', missingVars);
  process.exit(1);
}

console.log('‚úÖ Todas as vari√°veis de ambiente est√£o configuradas');
```

---

## üìä LOGS E MONITORAMENTO

### **1. Logs de Auditoria**

Adicione logs detalhados em pontos cr√≠ticos:

```javascript
// ‚úÖ Log de login bem-sucedido
console.log(`‚úÖ Login realizado: ${user.email} - IP: ${req.ip} - ${new Date().toISOString()}`);

// ‚úÖ Log de logout
console.log(`‚úÖ Logout realizado: ${user.email} - IP: ${req.ip} - ${new Date().toISOString()}`);

// ‚úÖ Log de tentativa de login inv√°lida
console.log(`‚ùå Tentativa de login inv√°lida: ${email} - IP: ${req.ip} - ${new Date().toISOString()}`);

// ‚úÖ Log de acesso negado
console.log(`‚ùå Acesso negado: ${req.user.email} tentou acessar dados de ${code_user} - IP: ${req.ip}`);

// ‚úÖ Log de sess√£o expirada
console.log(`‚è∞ Sess√£o expirada: ${user.email} - Token: ${sessionToken}`);
```

### **2. M√©tricas de Sess√£o**

```javascript
// ‚úÖ Fun√ß√£o para obter m√©tricas de sess√£o
async function getSessionMetrics() {
  try {
    const response = await fetch(`${process.env.DIRECTUS_API_URL}/items/Users?filter[is_session_active][_eq]=true`, {
      headers: {
        'Authorization': `Bearer ${process.env.DIRECTUS_API_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });
    
    const users = await response.json();
    
    console.log(`üìä Sess√µes ativas: ${users.data?.length || 0}`);
    
    return {
      activeSessions: users.data?.length || 0,
      timestamp: new Date().toISOString()
    };
  } catch (error) {
    console.error('Erro ao obter m√©tricas:', error);
    return null;
  }
}

// ‚úÖ Executar m√©tricas a cada 30 minutos
setInterval(getSessionMetrics, 1800000);
```

---

## üöÄ ORDEM DE IMPLEMENTA√á√ÉO

### **Fase 1: Prepara√ß√£o (1-2 horas)**
1. ‚úÖ Adicionar campos de sess√£o na tabela `Users`
2. ‚úÖ Criar √≠ndices para performance
3. ‚úÖ Configurar vari√°veis de ambiente
4. ‚úÖ Instalar depend√™ncias necess√°rias

### **Fase 2: Backend (3-4 horas)**
1. ‚úÖ Implementar rotas de autentica√ß√£o (`/api/auth/*`)
2. ‚úÖ Implementar rotas protegidas (`/api/directus/*`)
3. ‚úÖ Criar middleware de filtro de dados
4. ‚úÖ Configurar limpeza autom√°tica de sess√µes

### **Fase 3: Testes (1-2 horas)**
1. ‚úÖ Testar login/logout
2. ‚úÖ Testar requisi√ß√µes autenticadas
3. ‚úÖ Testar filtros de dados
4. ‚úÖ Testar expira√ß√£o de sess√µes

### **Fase 4: Frontend (1-2 horas)**
1. ‚úÖ Atualizar `apiRequest.js`
2. ‚úÖ Atualizar componentes de login/logout
3. ‚úÖ Atualizar m√≥dulo `User.js`
4. ‚úÖ Testar integra√ß√£o completa

---

## ‚ö†Ô∏è PONTOS DE ATEN√á√ÉO

### **1. Configura√ß√µes Obrigat√≥rias**
- ‚úÖ HTTPS em produ√ß√£o (cookies seguros)
- ‚úÖ CORS configurado para incluir cookies
- ‚úÖ Vari√°veis de ambiente no servidor apenas
- ‚úÖ Logs de auditoria implementados

### **2. Testes Essenciais**
- ‚úÖ Login com credenciais v√°lidas
- ‚úÖ Login com credenciais inv√°lidas
- ‚úÖ Requisi√ß√µes autenticadas
- ‚úÖ Logout e limpeza de sess√£o
- ‚úÖ Expira√ß√£o autom√°tica de sess√µes
- ‚úÖ Filtros de dados funcionando

### **3. Monitoramento**
- ‚úÖ Logs de tentativas de login
- ‚úÖ M√©tricas de sess√µes ativas
- ‚úÖ Limpeza autom√°tica funcionando
- ‚úÖ Performance das consultas

---

## üìö CONCLUS√ÉO

Este manual fornece uma implementa√ß√£o completa e segura do sistema de autentica√ß√£o, eliminando as vulnerabilidades cr√≠ticas identificadas. O sistema implementado oferece:

### **Benef√≠cios de Seguran√ßa:**
- ‚úÖ Elimina√ß√£o da chave API compartilhada
- ‚úÖ Cookies HttpOnly protegidos contra XSS
- ‚úÖ Sess√µes individuais por usu√°rio
- ‚úÖ Controle granular de acesso a dados
- ‚úÖ Logs de auditoria detalhados

### **Benef√≠cios T√©cnicos:**
- ‚úÖ C√≥digo modular e bem documentado
- ‚úÖ F√°cil manuten√ß√£o e extens√£o
- ‚úÖ Performance otimizada com √≠ndices
- ‚úÖ Limpeza autom√°tica de recursos
- ‚úÖ Monitoramento integrado

O sistema est√° pronto para produ√ß√£o e oferece uma base segura e robusta para o crescimento da aplica√ß√£o.

---

**Documento criado em:** $(date)  
**Vers√£o:** 1.0  
**Status:** ‚úÖ Pronto para Implementa√ß√£o  
**Prioridade:** CR√çTICA
