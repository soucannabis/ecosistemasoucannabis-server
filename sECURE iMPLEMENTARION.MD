# ğŸ” Manual de ImplementaÃ§Ã£o - Backend Seguro

## ğŸ“‹ VisÃ£o Geral

Este manual fornece instruÃ§Ãµes detalhadas para implementar o sistema de autenticaÃ§Ã£o seguro no backend, substituindo a vulnerabilidade crÃ­tica da chave API compartilhada por um sistema robusto baseado em cookies HttpOnly e gerenciamento de sessÃµes individuais.

---

## ğŸ—„ï¸ ESTRUTURA DO BANCO DE DADOS

### **1. Campos na Tabela `Users` (Adicionar Apenas 4 Campos de SessÃ£o)**

Adicione apenas os seguintes 4 campos necessÃ¡rios para o gerenciamento de sessÃµes:

```sql
-- âœ… CAMPOS DE SESSÃƒO (adicionar para gerenciamento de sessÃµes)
ALTER TABLE Users ADD COLUMN IF NOT EXISTS session_token VARCHAR(255) UNIQUE;
ALTER TABLE Users ADD COLUMN IF NOT EXISTS session_expires TIMESTAMP;
ALTER TABLE Users ADD COLUMN IF NOT EXISTS last_activity TIMESTAMP;
ALTER TABLE Users ADD COLUMN IF NOT EXISTS is_session_active BOOLEAN DEFAULT FALSE;

```
OS CAMPOS JA FORAM CRIADOS MANUALMENTE DO DATABASE.
---

## ğŸ› ï¸ IMPLEMENTAÃ‡ÃƒO DAS ROTAS DA API

### **1. ConfiguraÃ§Ã£o Inicial do Servidor**

#### **1.1 Instalar DependÃªncias NecessÃ¡rias**
```bash
npm install cookie-parser cors express
npm install --save-dev nodemon
```

#### **1.2 ConfiguraÃ§Ã£o Base do Servidor (`server.js`)**
```javascript
const express = require('express');
const cookieParser = require('cookie-parser');
const cors = require('cors');
const crypto = require('crypto');

const app = express();
const PORT = process.env.PORT || 3000;

// âœ… Configurar CORS para cookies
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:5173',
  credentials: true // Permite cookies
}));

// âœ… Middlewares essenciais
app.use(express.json());
app.use(cookieParser());

// âœ… VariÃ¡veis de ambiente seguras (apenas no servidor)
const DIRECTUS_API_TOKEN = process.env.DIRECTUS_API_TOKEN;
const DIRECTUS_API_URL = process.env.DIRECTUS_API_URL;
const PASS_ENCRYPT_KEY = process.env.PASS_ENCRYPT_KEY;
const JWT_SECRET = process.env.JWT_SECRET;

// âœ… ConfiguraÃ§Ã£o de cookies seguros
app.use((req, res, next) => {
  res.cookie = (name, value, options = {}) => {
    const defaultOptions = {
      httpOnly: true,        // NÃ£o acessÃ­vel via JavaScript
      secure: process.env.NODE_ENV === 'production', // HTTPS em produÃ§Ã£o
      sameSite: 'strict',    // ProteÃ§Ã£o contra CSRF
      path: '/'              // DisponÃ­vel em todo o site
    };
    
    const cookieString = `${name}=${value}; ${Object.entries({...defaultOptions, ...options})
      .map(([key, val]) => `${key}=${val}`)
      .join('; ')}`;
    
    res.setHeader('Set-Cookie', cookieString);
  };
  next();
});

// âœ… Importar e aplicar middleware de filtro de dados
const dataFilterMiddleware = require('./middleware/dataFilterMiddleware');
app.use('/api', dataFilterMiddleware);

// âœ… Importar rotas de autenticaÃ§Ã£o
const authRoutes = require('./routes/auth');
app.use('/api/auth', authRoutes);

// âœ… Importar rotas protegidas
const protectedRoutes = require('./routes/protected');
app.use('/api/directus', protectedRoutes);

// âœ… Iniciar servidor
app.listen(PORT, () => {
  console.log(`ğŸš€ Servidor rodando na porta ${PORT}`);
  console.log(`ğŸ”’ Sistema de autenticaÃ§Ã£o seguro ativo`);
});
```

### **2. Rotas de AutenticaÃ§Ã£o (`routes/auth.js`)**

#### **2.1 POST `/api/auth/login`**
```javascript
const express = require('express');
const crypto = require('crypto');
const router = express.Router();

// âœ… FunÃ§Ã£o para validar credenciais
async function validateUserCredentials(email, password) {
  try {
    // Buscar usuÃ¡rio usando credenciais do servidor
    const userResponse = await fetch(`${process.env.DIRECTUS_API_URL}/items/Users?filter[email_account][_eq]=${email}`, {
      headers: {
        'Authorization': `Bearer ${process.env.DIRECTUS_API_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });
    
    const users = await userResponse.json();
    
    if (users.data && users.data.length > 0) {
      const user = users.data[0];
      
      // Descriptografar senha no servidor usando chave segura
      const decryptedPassword = decryptPassword(user.pass_account, process.env.PASS_ENCRYPT_KEY);
      
      // Comparar senhas no servidor
      if (decryptedPassword === password) {
        return {
          id: user.id,
          user_code: user.user_code,
          name: user.name,
          email: user.email_account
        };
      }
    }
    
    return null;
  } catch (error) {
    console.error('Erro na validaÃ§Ã£o:', error);
    return null;
  }
}

// âœ… FunÃ§Ã£o para descriptografar senha
function decryptPassword(encryptedPassword, key) {
  try {
    const decipher = crypto.createDecipher('aes-256-cbc', key);
    let decrypted = decipher.update(encryptedPassword, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
  } catch (error) {
    console.error('Erro na descriptografia:', error);
    return null;
  }
}

// âœ… FunÃ§Ã£o para gerar token seguro
function generateSecureToken() {
  return crypto.randomBytes(32).toString('hex');
}

// âœ… FunÃ§Ã£o para salvar sessÃ£o
async function saveUserSession(userId, sessionToken) {
  try {
    const expiresAt = new Date(Date.now() + 3600000); // 1 hora
    
    const sessionData = {
      session_token: sessionToken,
      session_expires: expiresAt.toISOString(),
      last_activity: new Date().toISOString(),
      is_session_active: true
    };
    
    const response = await fetch(`${process.env.DIRECTUS_API_URL}/items/Users/${userId}`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${process.env.DIRECTUS_API_TOKEN}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(sessionData)
    });
    
    return response.ok;
  } catch (error) {
    console.error('Erro ao salvar sessÃ£o:', error);
    return false;
  }
}

// âœ… ROTA: POST /api/auth/login
router.post('/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // Validar entrada
    if (!email || !password) {
      return res.status(400).json({ 
        success: false, 
        message: 'Email e senha sÃ£o obrigatÃ³rios' 
      });
    }
    
    // Validar credenciais
    const user = await validateUserCredentials(email, password);
    
    if (user) {
      // Gerar token Ãºnico
      const sessionToken = generateSecureToken();
      
      // Salvar sessÃ£o
      const sessionSaved = await saveUserSession(user.id, sessionToken);
      
      if (sessionSaved) {
        // Definir cookie HttpOnly
        res.cookie('session_token', sessionToken, {
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'strict',
          maxAge: 3600000 // 1 hora
        });
        
        // Log de auditoria
        console.log(`âœ… Login realizado: ${user.email} - ${new Date().toISOString()}`);
        
        res.json({
          success: true,
          user: {
            user_code: user.user_code,
            name: user.name,
            email: user.email
          }
        });
      } else {
        res.status(500).json({ 
          success: false, 
          message: 'Erro ao criar sessÃ£o' 
        });
      }
    } else {
      // Log de tentativa de login invÃ¡lida
      console.log(`âŒ Tentativa de login invÃ¡lida: ${email} - ${new Date().toISOString()}`);
      
      res.status(401).json({ 
        success: false, 
        message: 'Credenciais invÃ¡lidas' 
      });
    }
  } catch (error) {
    console.error('Erro no login:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Erro interno do servidor' 
    });
  }
});

module.exports = router;
```

#### **2.2 GET `/api/auth/me`**
```javascript
// âœ… Middleware de autenticaÃ§Ã£o
async function authMiddleware(req, res, next) {
  try {
    const sessionToken = req.cookies.session_token;
    
    if (!sessionToken) {
      return res.status(401).json({ success: false, message: 'NÃ£o autenticado' });
    }
    
    // Verificar sessÃ£o no banco (buscar usuÃ¡rio pelo session_token)
    const userResponse = await fetch(`${process.env.DIRECTUS_API_URL}/items/Users?filter[session_token][_eq]=${sessionToken}&filter[is_session_active][_eq]=true`, {
      headers: {
        'Authorization': `Bearer ${process.env.DIRECTUS_API_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });
    
    const users = await userResponse.json();
    
    if (!users.data || users.data.length === 0) {
      return res.status(401).json({ success: false, message: 'SessÃ£o invÃ¡lida' });
    }
    
    const user = users.data[0];
    
    // Verificar se nÃ£o expirou
    if (new Date() > new Date(user.session_expires)) {
      // Marcar como inativa
      await invalidateUserSession(sessionToken);
      return res.status(401).json({ success: false, message: 'SessÃ£o expirada' });
    }
    
    // Adicionar dados do usuÃ¡rio Ã  requisiÃ§Ã£o
    req.user = {
      id: user.id,
      user_code: user.user_code,
      name: user.name,
      email: user.email_account
    };
    
    // Atualizar Ãºltima atividade
    await fetch(`${process.env.DIRECTUS_API_URL}/items/Users/${user.id}`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${process.env.DIRECTUS_API_TOKEN}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        last_activity: new Date().toISOString()
      })
    });
    
    next();
  } catch (error) {
    console.error('Erro no middleware de auth:', error);
    res.status(500).json({ success: false, message: 'Erro interno' });
  }
}

// âœ… ROTA: GET /api/auth/me
router.get('/me', authMiddleware, async (req, res) => {
  try {
    res.json({
      success: true,
      user: {
        user_code: req.user.user_code,
        name: req.user.name,
        email: req.user.email
      }
    });
  } catch (error) {
    console.error('Erro ao obter usuÃ¡rio:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Erro interno do servidor' 
    });
  }
});

module.exports = { router, authMiddleware };
```

#### **2.3 POST `/api/auth/logout`**
```javascript
// âœ… FunÃ§Ã£o para invalidar sessÃ£o
async function invalidateUserSession(sessionToken) {
  try {
    // Buscar usuÃ¡rio pelo session_token
    const userResponse = await fetch(`${process.env.DIRECTUS_API_URL}/items/Users?filter[session_token][_eq]=${sessionToken}`, {
      headers: {
        'Authorization': `Bearer ${process.env.DIRECTUS_API_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });
    
    const users = await userResponse.json();
    
    if (users.data && users.data.length > 0) {
      const user = users.data[0];
      
      // Invalidar sessÃ£o do usuÃ¡rio
      const response = await fetch(`${process.env.DIRECTUS_API_URL}/items/Users/${user.id}`, {
        method: 'PATCH',
        headers: {
          'Authorization': `Bearer ${process.env.DIRECTUS_API_TOKEN}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          is_session_active: false,
          session_token: null,
          session_expires: null
        })
      });
      
      return response.ok;
    }
    
    return true; // Se nÃ£o encontrou usuÃ¡rio, considera como sucesso
  } catch (error) {
    console.error('Erro ao invalidar sessÃ£o:', error);
    return false;
  }
}

// âœ… ROTA: POST /api/auth/logout
router.post('/logout', authMiddleware, async (req, res) => {
  try {
    const sessionToken = req.cookies.session_token;
    
    // Invalidar sessÃ£o no banco
    await invalidateUserSession(sessionToken);
    
    // Limpar cookie
    res.clearCookie('session_token');
    
    // Log de auditoria
    console.log(`âœ… Logout realizado: ${req.user.email} - ${new Date().toISOString()}`);
    
    res.json({ success: true });
  } catch (error) {
    console.error('Erro no logout:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Erro interno do servidor' 
    });
  }
});

module.exports = router;
```

### **3. Rotas Protegidas (`routes/protected.js`)**

#### **3.1 POST `/api/directus/user` (Protegido)**
```javascript
const express = require('express');
const { authMiddleware } = require('./auth');
const router = express.Router();

// âœ… ROTA: POST /api/directus/user
router.post('/user', authMiddleware, async (req, res) => {
  try {
    const { code_user } = req.body;
    
    // Verificar se o usuÃ¡rio pode acessar esses dados
    if (req.user.user_code !== code_user) {
      console.log(`âŒ Tentativa de acesso negado: ${req.user.email} tentou acessar dados de ${code_user}`);
      return res.status(403).json({ 
        success: false, 
        message: 'Acesso negado' 
      });
    }
    
    // Buscar dados completos do usuÃ¡rio
    const userResponse = await fetch(`${process.env.DIRECTUS_API_URL}/items/Users?filter[user_code][_eq]=${code_user}`, {
      headers: {
        'Authorization': `Bearer ${process.env.DIRECTUS_API_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });
    
    const userData = await userResponse.json();
    
    if (userData.data && userData.data.length > 0) {
      // âœ… Filtrar dados sensÃ­veis - retornar apenas campos necessÃ¡rios
      const safeUserData = {
        id: userData.data[0].id,
        user_code: userData.data[0].user_code,
        name: userData.data[0].name,
        email: userData.data[0].email_account,
        // Adicionar outros campos nÃ£o sensÃ­veis conforme necessÃ¡rio
      };
      
      res.json(safeUserData);
    } else {
      res.status(404).json({ 
        success: false, 
        message: 'UsuÃ¡rio nÃ£o encontrado' 
      });
    }
  } catch (error) {
    console.error('Erro ao buscar usuÃ¡rio:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Erro interno do servidor' 
    });
  }
});

module.exports = router;
```

---

## ğŸ” MIDDLEWARE DE FILTRO DE DADOS

### **1. ImplementaÃ§Ã£o do `dataFilterMiddleware.js`**

Crie o arquivo `middleware/dataFilterMiddleware.js`:

```javascript
const dataFilterMiddleware = (req, res, next) => {
  // Intercepta res.json() para filtrar dados
  const originalJson = res.json;
  res.json = function(data) {
    const filteredData = filterDataByPath(data, req);
    return originalJson.call(this, filteredData);
  };
  next();
};

// âœ… FunÃ§Ã£o principal de filtragem
function filterDataByPath(data, req) {
  const route = req.baseUrl + req.path;
  const method = req.method;
  const query = req.query;
  const page = query?.info?.split("->")[0]?.trim();

  // âœ… ConfiguraÃ§Ã£o de filtros adaptada para o sistema atual
  const filters = {
    // Filtros para autenticaÃ§Ã£o
    '/api/auth/me': {
      'default': {
        'GET': {
          allowedFields: ['success', 'user']
        }
      }
    },

    // Filtros para dados de usuÃ¡rio
    '/api/directus/user': {
      'default': {
        'POST': {
          blockedFields: ['pass_account', 'internal_notes', 'admin_notes']
        }
      }
    },

    // Filtros para recuperaÃ§Ã£o de senha
    '/api/directus/user/verify-email': {
      '/nova-senha': {
        'GET': {
          allowedFields: ['email', 'id', 'user_code']
        },
        'POST': {
          allowedFields: ['success', 'message']
        }
      }
    },

    // Filtros para criaÃ§Ã£o de usuÃ¡rio
    '/api/directus/create-user': {
      'default': {
        'POST': {
          allowedFields: ['success', 'user_code', 'message']
        }
      }
    },

    // Filtros para busca de usuÃ¡rios
    '/api/directus/search': {
      'default': {
        'POST': {
          blockedFields: ['pass_account', 'internal_notes', 'admin_notes', 'personal_data']
        }
      }
    },

    // Filtros para upload de documentos
    '/api/directus/documents': {
      'default': {
        'POST': {
          allowedFields: ['success', 'message', 'file_id', 'file_url']
        },
        'GET': {
          blockedFields: ['internal_path', 'admin_notes']
        }
      }
    },

    // Filtros para agendamentos mÃ©dicos
    '/api/directus/medical-appointment': {
      'default': {
        'POST': {
          allowedFields: ['success', 'message', 'appointment_id']
        },
        'GET': {
          blockedFields: ['internal_notes', 'admin_notes']
        }
      }
    },

    // Filtros para dados de associados
    '/api/directus/associate-signup': {
      'default': {
        'POST': {
          allowedFields: ['success', 'message', 'user_code']
        }
      }
    },

    // Filtros para dados de pacientes
    '/api/directus/patient-signup': {
      'default': {
        'POST': {
          allowedFields: ['success', 'message', 'user_code']
        }
      }
    }
  };

  // âœ… Buscar configuraÃ§Ã£o de filtro
  const filterConfig = findFilterConfig(filters, route, page, method);
  
  if (filterConfig) {
    // âœ… Aplicar filtro
    return applyFilter(data, filterConfig);
  }
  
  // âœ… Se nÃ£o hÃ¡ filtro configurado, retornar dados originais
  return data;
}

// âœ… FunÃ§Ã£o para encontrar configuraÃ§Ã£o de filtro
function findFilterConfig(filters, route, page, method) {
  // Buscar configuraÃ§Ã£o especÃ­fica para a rota
  const routeConfig = filters[route];
  if (!routeConfig) return null;

  // Buscar configuraÃ§Ã£o para a pÃ¡gina especÃ­fica
  const pageConfig = routeConfig[page] || routeConfig['default'];
  if (!pageConfig) return null;

  // Buscar configuraÃ§Ã£o para o mÃ©todo HTTP
  return pageConfig[method] || pageConfig['default'];
}

// âœ… FunÃ§Ã£o para aplicar filtro aos dados
function applyFilter(data, config) {
  if (!data) return data;

  // âœ… Tratar arrays
  if (Array.isArray(data)) {
    return data.map(item => filterObject(item, config));
  }

  // âœ… Tratar objetos Ãºnicos
  return filterObject(data, config);
}

// âœ… FunÃ§Ã£o para filtrar objeto individual
function filterObject(obj, config) {
  if (!obj || typeof obj !== 'object') return obj;

  const result = {};

  // âœ… Campos que sempre passam
  const specialFields = ['success', 'message', 'error', 'count', 'total', 'data'];

  Object.keys(obj).forEach(key => {
    // âœ… Campos especiais sempre passam
    if (specialFields.includes(key)) {
      result[key] = obj[key];
      return;
    }

    // âœ… Aplicar filtro de campos permitidos
    if (config.allowedFields) {
      if (config.allowedFields.includes(key)) {
        result[key] = obj[key];
      }
      return;
    }

    // âœ… Aplicar filtro de campos bloqueados
    if (config.blockedFields) {
      if (!config.blockedFields.includes(key)) {
        result[key] = obj[key];
      }
      return;
    }

    // âœ… Se nÃ£o hÃ¡ configuraÃ§Ã£o especÃ­fica, manter campo
    result[key] = obj[key];
  });

  return result;
}

module.exports = dataFilterMiddleware;
```

### **2. AplicaÃ§Ã£o do Middleware**

O middleware deve ser aplicado no `server.js` antes das rotas:

```javascript
// âœ… Importar middleware de filtro de dados
const dataFilterMiddleware = require('./middleware/dataFilterMiddleware');

// âœ… Aplicar middleware a todas as rotas /api/*
app.use('/api', dataFilterMiddleware);

// âœ… Importar rotas (apÃ³s o middleware)
const authRoutes = require('./routes/auth');
const protectedRoutes = require('./routes/protected');

app.use('/api/auth', authRoutes);
app.use('/api/directus', protectedRoutes);
```

---

## ğŸ§¹ LIMPEZA AUTOMÃTICA DE SESSÃ•ES

### **1. Job de Limpeza (Adicionar ao `server.js`)**

```javascript
// âœ… Limpeza automÃ¡tica de sessÃµes (executar a cada hora)
setInterval(async () => {
  try {
    const now = new Date().toISOString();
    
    // Buscar usuÃ¡rios com sessÃµes expiradas
    const expiredUsersResponse = await fetch(`${process.env.DIRECTUS_API_URL}/items/Users?filter[session_expires][_lt]=${now}&filter[is_session_active][_eq]=true`, {
      headers: {
        'Authorization': `Bearer ${process.env.DIRECTUS_API_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });
    
    const expiredUsers = await expiredUsersResponse.json();
    
    if (expiredUsers.data && expiredUsers.data.length > 0) {
      // Invalidar sessÃµes expiradas
      for (const user of expiredUsers.data) {
        await fetch(`${process.env.DIRECTUS_API_URL}/items/Users/${user.id}`, {
          method: 'PATCH',
          headers: {
            'Authorization': `Bearer ${process.env.DIRECTUS_API_TOKEN}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            is_session_active: false,
            session_token: null,
            session_expires: null
          })
        });
      }
      
      console.log(`ğŸ§¹ ${expiredUsers.data.length} sessÃµes expiradas limpas: ${new Date().toISOString()}`);
    }
  } catch (error) {
    console.error('âŒ Erro ao limpar sessÃµes:', error);
  }
}, 3600000); // 1 hora
```

---

## ğŸ”§ VARIÃVEIS DE AMBIENTE

### **1. Arquivo `.env` (Criar no servidor)**

```bash
# âœ… ConfiguraÃ§Ãµes do servidor
PORT=3000
NODE_ENV=production

# âœ… ConfiguraÃ§Ãµes do frontend
FRONTEND_URL=https://seudominio.com

# âœ… Credenciais do Directus (APENAS NO SERVIDOR)
DIRECTUS_API_TOKEN=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
DIRECTUS_API_URL=https://directus-production-3403.up.railway.app
PASS_ENCRYPT_KEY=sua_chave_de_criptografia_super_secreta
JWT_SECRET=sua_chave_jwt_super_secreta

# âœ… ConfiguraÃ§Ãµes de seguranÃ§a
SESSION_TIMEOUT=3600000
MAX_LOGIN_ATTEMPTS=5
```

### **2. VerificaÃ§Ã£o de VariÃ¡veis**

Adicione ao inÃ­cio do `server.js`:

```javascript
// âœ… Verificar variÃ¡veis de ambiente obrigatÃ³rias
const requiredEnvVars = [
  'DIRECTUS_API_TOKEN',
  'DIRECTUS_API_URL',
  'PASS_ENCRYPT_KEY',
  'JWT_SECRET'
];

const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);

if (missingVars.length > 0) {
  console.error('âŒ VariÃ¡veis de ambiente obrigatÃ³rias nÃ£o encontradas:', missingVars);
  process.exit(1);
}

console.log('âœ… Todas as variÃ¡veis de ambiente estÃ£o configuradas');
```

---

## ğŸ“Š LOGS E MONITORAMENTO

### **1. Logs de Auditoria**

Adicione logs detalhados em pontos crÃ­ticos:

```javascript
// âœ… Log de login bem-sucedido
console.log(`âœ… Login realizado: ${user.email} - IP: ${req.ip} - ${new Date().toISOString()}`);

// âœ… Log de logout
console.log(`âœ… Logout realizado: ${user.email} - IP: ${req.ip} - ${new Date().toISOString()}`);

// âœ… Log de tentativa de login invÃ¡lida
console.log(`âŒ Tentativa de login invÃ¡lida: ${email} - IP: ${req.ip} - ${new Date().toISOString()}`);

// âœ… Log de acesso negado
console.log(`âŒ Acesso negado: ${req.user.email} tentou acessar dados de ${code_user} - IP: ${req.ip}`);

// âœ… Log de sessÃ£o expirada
console.log(`â° SessÃ£o expirada: ${user.email} - Token: ${sessionToken}`);
```

### **2. MÃ©tricas de SessÃ£o**

```javascript
// âœ… FunÃ§Ã£o para obter mÃ©tricas de sessÃ£o
async function getSessionMetrics() {
  try {
    const response = await fetch(`${process.env.DIRECTUS_API_URL}/items/Users?filter[is_session_active][_eq]=true`, {
      headers: {
        'Authorization': `Bearer ${process.env.DIRECTUS_API_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });
    
    const users = await response.json();
    
    console.log(`ğŸ“Š SessÃµes ativas: ${users.data?.length || 0}`);
    
    return {
      activeSessions: users.data?.length || 0,
      timestamp: new Date().toISOString()
    };
  } catch (error) {
    console.error('Erro ao obter mÃ©tricas:', error);
    return null;
  }
}

// âœ… Executar mÃ©tricas a cada 30 minutos
setInterval(getSessionMetrics, 1800000);
```

---

## ğŸš€ ORDEM DE IMPLEMENTAÃ‡ÃƒO

### **Fase 1: PreparaÃ§Ã£o (1-2 horas)**
1. âœ… Adicionar campos de sessÃ£o na tabela `Users`
2. âœ… Criar Ã­ndices para performance
3. âœ… Configurar variÃ¡veis de ambiente
4. âœ… Instalar dependÃªncias necessÃ¡rias

### **Fase 2: Backend (3-4 horas)**
1. âœ… Implementar rotas de autenticaÃ§Ã£o (`/api/auth/*`)
2. âœ… Implementar rotas protegidas (`/api/directus/*`)
3. âœ… Criar middleware de filtro de dados
4. âœ… Configurar limpeza automÃ¡tica de sessÃµes

### **Fase 3: Testes (1-2 horas)**
1. âœ… Testar login/logout
2. âœ… Testar requisiÃ§Ãµes autenticadas
3. âœ… Testar filtros de dados
4. âœ… Testar expiraÃ§Ã£o de sessÃµes

### **Fase 4: Frontend (1-2 horas)**
1. âœ… Atualizar `apiRequest.js`
2. âœ… Atualizar componentes de login/logout
3. âœ… Atualizar mÃ³dulo `User.js`
4. âœ… Testar integraÃ§Ã£o completa

---

## âš ï¸ PONTOS DE ATENÃ‡ÃƒO

### **1. ConfiguraÃ§Ãµes ObrigatÃ³rias**
- âœ… HTTPS em produÃ§Ã£o (cookies seguros)
- âœ… CORS configurado para incluir cookies
- âœ… VariÃ¡veis de ambiente no servidor apenas
- âœ… Logs de auditoria implementados

### **2. Testes Essenciais**
- âœ… Login com credenciais vÃ¡lidas
- âœ… Login com credenciais invÃ¡lidas
- âœ… RequisiÃ§Ãµes autenticadas
- âœ… Logout e limpeza de sessÃ£o
- âœ… ExpiraÃ§Ã£o automÃ¡tica de sessÃµes
- âœ… Filtros de dados funcionando

### **3. Monitoramento**
- âœ… Logs de tentativas de login
- âœ… MÃ©tricas de sessÃµes ativas
- âœ… Limpeza automÃ¡tica funcionando
- âœ… Performance das consultas

---

## ğŸ“š CONCLUSÃƒO

Este manual fornece uma implementaÃ§Ã£o completa e segura do sistema de autenticaÃ§Ã£o, eliminando as vulnerabilidades crÃ­ticas identificadas. O sistema implementado oferece:

### **BenefÃ­cios de SeguranÃ§a:**
- âœ… EliminaÃ§Ã£o da chave API compartilhada
- âœ… Cookies HttpOnly protegidos contra XSS
- âœ… SessÃµes individuais por usuÃ¡rio
- âœ… Controle granular de acesso a dados
- âœ… Logs de auditoria detalhados

### **BenefÃ­cios TÃ©cnicos:**
- âœ… CÃ³digo modular e bem documentado
- âœ… FÃ¡cil manutenÃ§Ã£o e extensÃ£o
- âœ… Performance otimizada com Ã­ndices
- âœ… Limpeza automÃ¡tica de recursos
- âœ… Monitoramento integrado

O sistema estÃ¡ pronto para produÃ§Ã£o e oferece uma base segura e robusta para o crescimento da aplicaÃ§Ã£o.

---

**Documento criado em:** $(date)  
**VersÃ£o:** 1.0  
**Status:** âœ… Pronto para ImplementaÃ§Ã£o  
**Prioridade:** CRÃTICA
